# how to read this grammar?
# ()    group of one or more rules
# ?     may appear
# ->    defining something in grammar
# *     may appear and repeat more than once
# ;     end of grammar rule
# ""    match value inside literal
# |     or, left or right may appear
# #     comment

program             -> declaration* EOF ;

declaration         -> useDecl | fnDecl | structDecl | structMethodDecl | varDecl | externDecl ;
useDecl             -> "use" path ";" ;
externDecl          -> "extern" "{" ( "pub"? prototype ";" )* "}" ;
fnDecl              -> prototype blockStmt ;
prototype           -> "pub"? "fn" IDENTIFIER "(" name_with_type ( "," name_with_type )* ")" ( "->" path )? ;
structDecl          -> "pub"? "struct" IDENTIFIER "{" "pub"? name_with_type ( "," "pub"? name_with_type )* "}" ;
structMethodDecl    -> "impl" IDENTIFIER "{" structFnDecl* "}" ;
varDecl             -> "let"  IDENTIFIER ( ":" path )? "=" expression ";" ;

fnDecl              -> "fn" IDENTIFIER "(" name_with_type | "self" ( "," name_with_type )* ")" statement ;
name_with_type      -> IDENTIFIER ":" path          # x: std::String

statement           -> ifStmt | forStmt | loopStmt | whileStmt | blockStmt | exprStmt | printStmt ;
ifStmt              -> "if" expression blockStmt ( "else" statement blockStmt )? ;
forStmt             -> "for" IDENTIFIER "in" expression blockStmt ;
loopStmt            -> "loop" blockStmt ;
whileStmt           -> "while" expression blockStmt ;
blockStmt           -> "{" statement* "}";
exprStmt            -> expression ";" ;
printStmt           -> expression ";" ;

expression          -> assignment ;
assignment          -> ( call "." )? IDENTIFIER (
                                                "&="    |
                                                "^="    |
                                                "|="    |
                                                "<<="   |
                                                ">>="   |
                                                "+="    |
                                                "-="    |
                                                "*="    |
                                                "/="    |
                                                "%="
                                                ) assignment | logical_or ;
logical_or          -> logical_and  ( "||" logical_and )* ;
logical_and         -> equality   ( "&&" equality  )* ;
equality            -> comparison ( ( "==" | "!=" ) comparison )* ;
comparison          -> bitwise_or ( ( "<"  | "<=" | ">" | ">=" ) bitwise_or )* ;
bitwise_or          -> bitwise_xor ( "|" bitwise_xor )* ;
bitwise_xor         -> bitwise_and ( "^" bitwise_and )* ;
bitwise_and         -> bitwise_shift ( "&" bitwise_shift )* ;
bitwise_shift       -> term ( ( "<<" | ">>" ) term )* ;
term                -> factor ( ( "+" | "-" ) factor)* ;
factor              -> unary  ( ( "/" | "*" | "%" ) unary )* ;
unary               -> ( "!" | "-" ) unary | call ;
call                -> primary ( "(" arguments ")" | "." IDENTIFIER ) ;
arguments           -> expression ( "," expression )* ;
primary             -> NUMBER | STRING | "true" | "false" | "null" | "(" expression ")" | IDENTIFIER | path ;
path                -> ( IDENTIFIER ( "::" path )* ) | ( "{" path ( "," path )* "}" ) ;